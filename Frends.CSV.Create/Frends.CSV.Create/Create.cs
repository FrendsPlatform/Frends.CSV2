using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Threading;
using System.Xml.Linq;
using CsvHelper;
using CsvHelper.Configuration;
using Frends.CSV.Create.Definitions;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using static System.Net.Mime.MediaTypeNames;

namespace Frends.CSV.Create;

/// <summary>
/// CSV Task.
/// </summary>
public class CSV
{
    /// <summary>
    /// Create a CSV string from a List, JSON string or XML string.
    /// [Documentation](https://tasks.frends.com/tasks/frends-tasks/Frends.CSV.Create)
    /// </summary>
    /// <param name="input">Input parameters</param>
    /// <param name="options">Optional parameters</param>
    /// <param name="cancellationToken">Token generated by Frends to stop this Task.</param>
    /// <returns>Object { bool Success, string CSV }</returns>
    public static Result Create([PropertyTab] Input input, [PropertyTab] Options options, CancellationToken cancellationToken)
    {
        var config = new CsvConfiguration(new CultureInfo(options.CultureInfo))
        {
            Delimiter = input.Delimiter,
            HasHeaderRecord = options.IncludeHeaderRow
        };

        if (options.NeverAddQuotesAroundValues)
        {
            config.Mode = CsvMode.NoEscape;
            // if IgnoreQuotes is true, seems like ShouldQuote function has to return false in all cases
            // if IgnoreQuotes is false ShouldQuote can't have any implementation otherwise it will overwrite IgnoreQuotes statement ( might turn it on again)
            config.ShouldQuote = (field) => (!options.NeverAddQuotesAroundValues);
        }
        var csv = string.Empty;

        switch (input.InputType)
        {
            case CreateInputType.List:
                csv = ListToCsvString(input.Data, input.Headers, config, options, cancellationToken);
                break;
            case CreateInputType.Json:
                csv = JsonToCsvString(input, config, options, cancellationToken);
                break;
            case CreateInputType.Xml:
                csv = XmlToCsvString(input.Xml, input.XmlNodeElementName, config, options, cancellationToken);
                break;
        }
        return new Result(true, csv);
    }

    private static string ListToCsvString(List<List<object>> inputData, List<string> inputHeaders, CsvConfiguration config, Options options, CancellationToken cancellationToken)
    {
        using var csvString = new StringWriter();
        using var csv = new CsvWriter(csvString, config);

        //Write the header row
        if (config.HasHeaderRecord && inputData.Any())
        {
            foreach (var column in inputHeaders)
            {
                cancellationToken.ThrowIfCancellationRequested();
                csv.WriteField(column);
            }

            csv.NextRecord();
        }

        foreach (var row in inputData)
        {
            foreach (var cell in row)
            {
                cancellationToken.ThrowIfCancellationRequested();
                csv.WriteField(cell ?? options.ReplaceNullsWith);
            }

            csv.NextRecord();
        }

        return csvString.ToString();
    }

    private static string JsonToCsvString(Input input, CsvConfiguration config, Options options, CancellationToken cancellationToken)
    {
        var json = StringifyJsonNumbers(input.Json);
        var jToken = JsonConvert.DeserializeObject<JToken>(
            json,
            new JsonSerializerSettings { DateParseHandling = DateParseHandling.None, }
        );
        var inputArray = jToken is JObject ? new JArray { jToken } : (JArray)jToken;

        // CSV part
        using var csvString = new StringWriter();
        using var csv = new CsvWriter(csvString, config);

        // If columns are specified manually
        if (input.SpecifyColumnsManually)
        {
            // Validate if columns are null or empty
            if (input.Columns == null || !input.Columns.Any())
            {
                throw new ArgumentException("Manual columns are specified but no columns are provided.");
            }

            // Write the manually specified header row
            if (config.HasHeaderRecord)
            {
                foreach (var header in input.Headers)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    csv.WriteField(header);
                }
                csv.NextRecord();
            }

            // Write the data rows using the specified JSON paths
            foreach (var row in inputArray)
            {
                foreach (var column in input.Columns)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    var value = row.SelectToken(column)?.ToString() ?? options.ReplaceNullsWith;
                    csv.WriteField(value);
                }
                csv.NextRecord();
            }
        }
        else
        {
            var limits = JsonArraysLimits(inputArray);
            var data = FlattenJson(inputArray, limits);

            // Write the automatically generated header row
            if (config.HasHeaderRecord && data.Any())
            {
                foreach (var column in data.First().Keys)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    csv.WriteField(column);
                }

                csv.NextRecord();
            }

            // Write the data rows
            foreach (var row in data)
            {
                foreach (var cell in row)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    csv.WriteField(cell.Value ?? options.ReplaceNullsWith);
                }

                csv.NextRecord();
            }
        }
        return csvString.ToString();
    }

    private static string XmlToCsvString(string xml, string node, CsvConfiguration config, Options options, CancellationToken cancellationToken)
    {
        using var csvString = new StringWriter();
        using var csv = new CsvWriter(csvString, config);

        XDocument xdoc = XDocument.Parse(xml);
        IEnumerable<XElement> nodes;
        if (string.IsNullOrEmpty(node))
            nodes = xdoc.Root.Elements();
        else
            nodes = xdoc.Descendants().Where(p => p.Name.LocalName.Equals(node));

        //Write the header row
        if (config.HasHeaderRecord && nodes.Any())
        {
            var headers = nodes.Descendants().Select(n => n.Name.LocalName).Distinct().ToList();

            foreach (var column in headers)
            {
                cancellationToken.ThrowIfCancellationRequested();
                csv.WriteField(column.ToString());
            }
            csv.NextRecord();
        }

        foreach (var column in nodes)
        {
            foreach (var cell in column.Elements().Select(n => n.Value).ToList())
            {
                cancellationToken.ThrowIfCancellationRequested();
                csv.WriteField(cell ?? options.ReplaceNullsWith);
            }
            csv.NextRecord();
        }

        return csvString.ToString();
    }

    private static string StringifyJsonNumbers(string json)
    {
        var jsonElement = System.Text.Json.JsonSerializer.Deserialize<JsonElement>(
            json,
            new JsonSerializerOptions { AllowTrailingCommas = true, }
        );
        string stringifiedJson = System.Text.Json.JsonSerializer.Serialize(
            jsonElement,
            new JsonSerializerOptions { Converters = { new NumberToStringConverter() } }
        );
        return stringifiedJson;
    }

    private static Dictionary<string, int> JsonArraysLimits(JArray jArray)
    {
        var limits = new Dictionary<string, int>();
        foreach (var row in jArray)
        {
            IEnumerable<JToken> jTokens = JObject.FromObject(row).Descendants().Where(p => !p.HasValues);
            JToken previousToken = null;

            foreach (JToken jToken in jTokens)
            {
                //checking only one element of the same parent
                if (previousToken == null || previousToken?.Parent?.Path != jToken?.Parent?.Path)
                {
                    if (jToken?.Parent?.Count > 1)
                    {
                        if (limits.TryGetValue(jToken.Parent.Path, out int limit))
                        {
                            if (limit < jToken.Parent.Count)
                            {
                                limits[jToken.Parent.Path] = jToken.Parent.Count;
                            }
                        }
                        else
                        {
                            limits.Add(jToken.Parent.Path, jToken.Parent.Count);
                        }
                    }
                }
            }
        }
        return limits;
    }

    private static List<Dictionary<string, string>> FlattenJson(JArray input, Dictionary<string, int> limits)
    {
        List<Dictionary<string, string>> data = new();
        foreach (var row in input)
        {
            JObject rowObject = JObject.FromObject(row);
            IEnumerable<JToken> jTokens = rowObject.Descendants().Where(p => !p.HasValues);
            JToken previousToken = null;

            Dictionary<string, string> results = jTokens.Aggregate(
                new Dictionary<string, string>(),
                (properties, jToken) =>
                {
                    //skip adding if same parent, because we added all elements of array with the first occurance
                    if (
                        previousToken == null
                        || previousToken?.Parent?.Path != jToken?.Parent?.Path
                    )
                    {
                        //adding array properties
                        if (limits.TryGetValue(jToken!.Parent!.Path, out int limit))
                        {
                            //adding first value for empty array
                            if (jToken.Type == JTokenType.Null)
                            {
                                properties.Add(jToken.Parent.Path + "[0]", "");
                            }
                            else
                            {
                                //adding all children of an array to properties
                                foreach (JToken child in jToken.Parent!.Children())
                                {
                                    properties.Add(
                                        child.Path.Replace("['", "").Replace("']", ""),
                                        child.Type == JTokenType.Null ? null : child.ToString()
                                    );
                                }
                            }

                            //add empty values to even size of all arrays
                            for (int i = jToken.Parent.Count; i < limit; i++)
                            {
                                properties.Add(jToken.Parent.Path + "[" + i + "]", "");
                            }
                        }
                        else
                        {
                            //adding non-array properties
                            properties.Add(
                                jToken.Path.Replace("['", "").Replace("']", ""),
                                jToken.Type == JTokenType.Null ? null : jToken.ToString()
                            );
                        }
                    }
                    previousToken = jToken;
                    return properties;
                }
            );
            data.Add(results);
        }

        return data;
    }
}